#!/usr/bin/env python3
import argparse
import sys
import os
import subprocess
import shutil
import multiprocessing

## CMake configured paths to the tools that we'll be using
CIRCT_BIN_DIR = "@CIRCT_INCLUDE_DIR@/../bin/"
CIRCT_HLS_BIN_DIR = "@CIRCT_HLS_BINARY_DIR@/bin/"
CIRCT_HLS_SOURCE_DIR = "@CIRCT_HLS_SOURCE_DIR@"
MLIR_CLANG_PATH = "@MLIR-CLANG_PATH@"
POLYGEIST_OPT_PATH = "@POLYGEIST-OPT_PATH@"
LLVM_BIN_DIR = "@LLVM_BINARY_DIR@/bin"

## Global variables used to drive the tool
# Current mode
mode = None
# Tool arguments
args = None


def print_header(text, width=80):
  if args.silent:
    return
  sideWidth = (width - len(text)) // 2 - 2
  print("=" * sideWidth + f" {text} " + "=" * sideWidth)


def print_prefixed(prefix, text):
  if args.silent:
    return
  print(f"{prefix}: {text}")


def print_info(text):
  print_prefixed("INFO", "    " + text)


def print_error(text):
  print_prefixed("ERROR", text)
  sys.exit(1)


def print_step(text):
  print_prefixed("\nSTEP", text)


def runIfNotExists(file, func):
  if not args.rebuild and os.path.exists(file):
    print_info(f"File {file} already exists, skipping...")
    return
  func()


def copyToCurrentDir(file, filename=None):
  hadFileName = filename is not None
  if filename is None:
    filename = os.path.basename(file)
  shutil.copy(file, filename)
  print_info("Copied '" + file + "' to current directory" +
             f" as {filename}" if hadFileName else "")


def run_tool(args, stdOutFile=None, shell=False, liveOutput=False):
  cmd = " ".join(args)

  def onError(returnCode, stdOut, stdErr):
    stdErr = str(stdErr).replace("\\n", "\n")
    print_error(
        f"Error while executing: {cmd}\nstdout:\n{stdOut}\nstderr:\n{stdErr}\n (code: {returnCode})"
    )

  try:
    if shell:
      proc = subprocess.Popen(cmd,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              shell=True)
      if liveOutput:
        # Continuously poll the process and forward any stdout
        while not proc.poll():
          stdoutdata = proc.stdout.readline()
          if stdoutdata:
            sys.stdout.write(stdoutdata.decode("utf-8"))
          else:
            code = proc.returncode
            break
          stdOut, stdErr = b'', b''
      else:
        code = proc.wait()
        stdOut, stdErr = proc.communicate()
    else:
      res = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      code = res.returncode
      stdOut, stdErr = res.stdout, res.stderr

    stdOut = stdOut.decode("utf-8")
    stdErr = stdErr.decode("utf-8")

    if code != 0:
      onError(code, stdOut, stdErr)

    if stdOutFile:
      with open(stdOutFile, 'wb') as f:
        f.write(stdOut)
  except subprocess.CalledProcessError as e:
    onError(e.returncode, "", e.output)


def run_fud(fromType, toType, inputFile, outputFile):
  if fromType == "" or toType == "":
    print_error("Error: Missing fromType or toType")
  run_tool([
      "fud", "exec", "--from", fromType, "--to", toType, "-o", outputFile,
      inputFile
  ])


def run_opt_tool(tool_dir, tool_name, args, inputFile=None, outputFile=None):
  args = [os.path.join(tool_dir, tool_name), *args]
  if inputFile:
    args.append(inputFile)
  run_tool(args, outputFile, shell=True)


def run_circt_opt(args, inputFile=None, outputFile=None):
  run_opt_tool(CIRCT_BIN_DIR, "circt-opt", args, inputFile, outputFile)


def run_hls_opt(args, inputFile=None, outputFile=None):
  run_opt_tool(CIRCT_HLS_BIN_DIR, "hls-opt", args, inputFile, outputFile)


def run_mlir_opt(args, inputFile, outputFile=None):
  run_opt_tool(LLVM_BIN_DIR, "mlir-opt", args, inputFile, outputFile)


class HLSMode:

  def __init__(self, name):
    self.name = name

  def add_arguments(self, subparser):
    raise NotImplementedError("implement me in a subclass")

  def parse_arguments(self, parser):
    raise NotImplementedError("implement me in a subclass")

  def gen_names(self):
    # Generates all possible output file names which we'll reference during the run.
    # Kernel files
    self.kernel_sv = os.path.join(args.outdir, args.kernel_name + ".sv")
    self.dotfile = os.path.join(args.outdir, args.kernel_name + ".dot")
    self.kernel_wrapper = os.path.join(args.outdir, args.kernel_name + ".cpp")

    # Testbench files
    self.tb_poly = os.path.join(args.outdir, args.kernel_name + "_poly.mlir")
    self.tb_poly_flat = os.path.join(args.outdir,
                                     args.kernel_name + "_poly_flat.mlir")
    self.tb_mlir = os.path.join(args.outdir, args.kernel_name + "_tb.mlir")
    self.tb_llvm = os.path.join(args.outdir, args.kernel_name + "_tb_llvm.mlir")
    self.tb_output = os.path.join(args.outdir,
                                  args.kernel_name + "_tb_output.txt")

    # Analysis files
    self.resource_estimate = os.path.join(
        args.outdir, args.kernel_name + "_resource_estimate.txt")

    # Mode-specific names
    self.gen_names_mode()

  def run(self):
    # Generate output file names used during the run.
    self.gen_names()

    # Top level runner. Non-mode specific run jobs
    # ...

    # Run mode specific jobs
    self.run_mode()

    # Run post-mode specific jobs
    if args.synth:
      self.run_synth()

    print_header("Finished!")

  def run_synth(self):
    print_step("Running Vivado resource estimation")

    # Copy .tcl and .xdc files to current directory
    copyToCurrentDir(
        os.path.join(CIRCT_HLS_SOURCE_DIR, "tools", "hlstool", "synth.tcl"))
    copyToCurrentDir(
        os.path.join(CIRCT_HLS_SOURCE_DIR, "tools", "hlstool", "device.xdc"))

    # Generate run commands
    vivado_args = ["vivado", "-mode", "batch", "-source", "synth.tcl"]
    # synth arguments (see synth.tcl)
    vivado_args.append("-tclargs")
    vivado_args.append(args.kernel_name)  # top level
    vivado_args.append("xczu3eg-sbva484-1-e")  # part
    vivado_args.append("vivado")  # outdir
    vivado_args.append("1")  # do routing

    print_info("Running Vivado with command: " + " ".join(vivado_args))
    run_tool(vivado_args, shell=True, liveOutput=not args.silent)


class DynamicMode(HLSMode):

  def __init__(self):
    super().__init__('dynamic')

  def add_arguments(self, subparser):
    dynamic_parser = subparser.add_parser('dynamic', help='Dynamic mode')
    dynamic_parser.add_argument('--run_sim',
                                action='store_true',
                                help='Run the HLT testbench.')

    dynamic_parser.add_argument(
        '-e',
        '--genexec',
        type=str,
        help="Generate a HLT testbench which compiles to an executable file. "
        "This is useful if you don\'t want to run the HLT wrapper via. the "
        "mlir-cpu-runner, but instead want an executable file that you can debug"
        " with regular C++ tools")

    dynamic_parser.add_argument(
        '--print_dot',
        help="Prints a dot file of the "
        "handshake circuit",
        action='store_true',
    )
    dynamic_parser.add_argument('--lower',
                                action='store_true',
                                help="Lower the C code to hardware.")
    dynamic_parser.add_argument(
        '--build_sim',
        action='store_true',
        help="Lower the C code to hardware, build the simulator.")
    dynamic_parser.add_argument(
        '--build_tb',
        action='store_true',
        help=
        "Lower the testbench to MLIR, asyncify it (for HLT use), convert to LLVM IR."
    )
    dynamic_parser.add_argument(
        '--hsdbg',
        action='store_true',
        help="Run HSDbg on the circuit. This"
        " assumes that a simulation has been run prior to this.")

  def parse_arguments(self, parser):
    if not args.vcd:
      # Infer a default location for the VCD file based on how HLT emits it.
      args.vcd = os.path.join(args.outdir, 'logs/vlt_dump.vcd')

    if args.hsdbg:
      # Always run print_dot
      args.print_dot |= True

      # If we are running HSDbg there must be simulation results available
      if not os.path.exists(args.vcd):
        parser.error(f"Expected a simulation result file at {args.vcd}. "
                     " Please run a simulation first.")

    if not args.build_sim and not args.lower and not args.run_sim and not \
      args.build_tb and not args.synth:
      # If no specific end-point has been set, we'll stop at building the sim
      # and kernel, but not running the sim.
      print_info("enabling --build_sim due to no specific end-point set")
      args.build_sim |= True
      print_info("enabling --build_tb due to no specific end-point set")
      args.build_tb |= True

    if args.synth:
      args.lower |= True
      print_info("enabling --lower required by --synth")

    if args.run_sim:
      # Running the sim requires building the sim
      args.build_sim |= True
      args.build_tb |= True
      print_info("enabling --build_sim required by --run_sim")
      print_info("enabling --build_tb required by --run_sim")

    if args.build_sim:
      # Building the sim requires lowering the kernel.
      args.lower |= True
      print_info("enabling --lower required by --build_sim")

  def gen_names_mode(self):
    # Generate dynamic-mode specific names.

    # Kernel files
    self.kernel_affine = os.path.join(args.outdir,
                                      args.kernel_name + "_affine.mlir")
    self.kernel_std = os.path.join(args.outdir, args.kernel_name + "_std.mlir")
    self.kernel_std_max = os.path.join(args.outdir,
                                       args.kernel_name + "_std_max.mlir")
    self.kernel_handshake_noid = os.path.join(
        args.outdir, args.kernel_name + "_handshake_noid.mlir")
    self.kernel_handshake = os.path.join(args.outdir,
                                         args.kernel_name + "_handshake.mlir")
    self.kernel_firrtl = os.path.join(args.outdir,
                                      args.kernel_name + "_firrtl.mlir")

  def run_mode(self):
    # First, generate all of the names that we'll reference during the run.
    self.gen_names()

    if args.lower:
      self.run_lowering()

    if args.build_tb:
      self.run_build_tb()

    if args.build_sim:
      self.run_build_sim()

    if args.print_dot:
      self.run_print_dot()

    if args.hsdbg:
      self.run_hsdbg()
      return

    if args.run_sim:
      self.run_sim()

  def run_lowering(self):
    # Main HLS driver, for bring C to system verilog.
    print_step(f"Dynamically scheduled HLS'ing {args.kernel_file}...")

    # Run polygeist, generating affine/SCF level MLIR.
    runIfNotExists(
        self.kernel_affine, lambda: run_fud("c", "mlir-affine", args.
                                            kernel_file, self.kernel_affine))
    print_info(f"Lowered to affine! (Polygeist)...! ({self.kernel_affine})")

    # Lower the affine code into flattened standard. By flattened, we mean that
    # all memrefs are unidimensional, since this is what is supported by the
    # handshake passes.
    runIfNotExists(
        self.kernel_std, lambda: run_fud("mlir-affine", "mlir-std-flattened",
                                         self.kernel_affine, self.kernel_std))

    # Put into maximized SSA form (precondition for correct handshake lowering)
    runIfNotExists(
        self.kernel_std_max,
        lambda: run_hls_opt(['--max-ssa=\"ignore-memref\"'], self.kernel_std,
                            self.kernel_std_max))
    print_info(f"Lowered to standard...! ({self.kernel_std_max})")

    # Add buffers to the circuit
    # @TODO: should expose a flag to the user to choose the buffer strategy.
    runIfNotExists(
        self.kernel_handshake_noid,
        lambda: run_fud("mlir-std-flattened", "mlir-handshake-buffered", self.
                        kernel_std_max, self.kernel_handshake_noid))

    # Run the add-ids pass to ensure that we have a deterministic mapping between
    # the FIRRTL/SV code and the Handshake IR/.dot file
    runIfNotExists(
        self.kernel_handshake,
        lambda: run_circt_opt(["--handshake-add-ids"], self.
                              kernel_handshake_noid, self.kernel_handshake))
    print_info(f"Lowered to handshake...! ({self.kernel_handshake})")

    # Lower to FIRRTL
    runIfNotExists(
        self.kernel_firrtl,
        lambda: run_fud("mlir-handshake-buffered", "mlir-firrtl", self.
                        kernel_handshake, self.kernel_firrtl))
    print_info(f"Lowered to FIRRTL...! ({self.kernel_firrtl})")

    # Lower to SV
    runIfNotExists(
        self.kernel_sv, lambda: run_fud("mlir-firrtl", "synth-verilog", self.
                                        kernel_firrtl, self.kernel_sv))
    print_info(f"Lowered to RTL...! ({self.kernel_sv})")

  def run_print_dot(self):
    print_step("Printing dot file of the handshake circuit...")
    run_circt_opt(["--handshake-print-dot"], self.kernel_handshake)

  def run_hsdbg(self):
    print_step("Running HSDbg on the handshake circuit...")
    hsdbg_cmd = [
        os.path.join(CIRCT_HLS_BIN_DIR, "hsdbg"), "-f=dec", self.dotfile,
        args.vcd
    ]
    cmd = ["xterm", "-e", f'\'{" ".join(hsdbg_cmd)}\'']

    print_info(f"Starting HSDbg in separate terminal")
    proc = subprocess.Popen(" ".join(cmd),
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            shell=True)

  def run_genexec(self):
    pass

  def run_build_sim(self):
    print_step("Building simulator")

    # Generate HLT wrapper. This will create a '{kernel_name}.cpp' file in the
    # output directory.
    runIfNotExists(
        self.kernel_wrapper, lambda: run_tool([
            os.path.join(CIRCT_HLS_BIN_DIR, "hlt-wrapgen"
                        ), "--func", self.kernel_std, "--ref", self.
            kernel_handshake, "--kernel", self.kernel_firrtl, "--name", args.
            kernel_name, "--type=handshakeFIRRTL", "-o", "."
        ],
                                              shell=True))
    print_info(f"Created HLT wrapper ({self.kernel_wrapper})")

    # Copy the prewritten CMakeLists.txt file to the output directory.
    # This is the file that does the heavy lifting in terms of configuring the
    # simulator library that we're building.
    htl_cmake = os.path.join(
        CIRCT_HLS_BIN_DIR, "..",
        "tools/hlt/Simulator/hlt_verilator_CMakeLists.txt")
    copyToCurrentDir(htl_cmake, "CMakeLists.txt")
    print_info("Added CMakeLists.txt to the build directory")

    # Remove any stale CMakeCache files
    if os.path.exists("CMakeCache.txt"):
      os.remove("CMakeCache.txt")

    # Run CMake and build the simulator library.
    cmake_args = ["-G", "Ninja"]
    cmake_args.append(f"-DHLT_TESTNAME={args.kernel_name}")
    # Enable tracing?
    if not args.no_trace:
      cmake_args.append(f"-DHLT_TRACE=1")
    cmake_args.append(f"-DHLT_THREADS={args.vlt_threads}")
    cmake_args.append(f"-DCMAKE_BUILD_TYPE=RelWithDebInfo")
    # Run cmake in current directory
    cmake_args.append(".")
    print_info("Running CMake with arguments: " + " ".join(cmake_args))
    run_tool(["cmake", *cmake_args])
    print_info("Running ninja")
    run_tool(["ninja"])

  def run_build_tb(self):
    print_step("Building testbench")

    # Lower polygeist to MLIR. Ensure to run polygeist canonicalization since
    # a lot of pointer/memref legalization takes places within the canonicalization
    # patterns of Polygeist.
    runIfNotExists(
        self.tb_poly,
        lambda: run_tool(
            [
                MLIR_CLANG_PATH,
                "-S",  # Emit assembly (MLIR)
                "--function=*",  # Emit all functions
                "--memref-fullrank",  # Emit fullrank memrefs
                args.tb_file,
                "|",  # pipe stdout
                POLYGEIST_OPT_PATH,  # Run Polygeist optimization driver
                "--canonicalize",  # ensure that the polygeist-emitted IR is canonical. This may remove some polygeist-dialect specific ops.
            ],
            self.tb_poly,
            shell=True))
    print_info(f"Lowered testbench to MLIR ({self.tb_poly})")

    # Run memref-call flattening. This is specific to handshake kernels since they do
    # not support multidimensional memories at the moment
    runIfNotExists(
        self.tb_poly_flat, lambda: run_circt_opt(
            ["--flatten-memref-calls"], self.tb_poly, self.tb_poly_flat))
    print_info(
        f"flattened multidimensional memref's in calls to unidimensional ({self.tb_poly_flat})"
    )

    # Asynchronize to adhere with HLT. We assume that the testname is equal to the
    # kernel name - which in turn is the function to asynchronize.
    runIfNotExists(
        self.tb_mlir, lambda: run_hls_opt([
            f"--asyncify-calls=\"function={args.kernel_name}\""
        ], self.tb_poly_flat, self.tb_mlir))
    print_info(f"Async-ified the testbench ({self.tb_mlir})")

    runIfNotExists(
        self.tb_llvm, lambda: run_mlir_opt([
            "-lower-affine", "-convert-scf-to-std", "-std-expand",
            "-convert-memref-to-llvm", "-convert-std-to-llvm",
            "-reconcile-unrealized-casts"
        ], self.tb_mlir, self.tb_llvm))
    print_info(f"Lowered testbench to LLVMIR ({self.tb_llvm})")

  def run_sim(self):
    print_step("Running testbench")
    # Directory containing LLVM libraries which we'll need to dynamically link
    # against in the mlir-cpu-runner
    libdir = os.path.join(LLVM_BIN_DIR, "..", "lib")

    # Shared library built by the simulator (see 'run_build_sim').
    simlib = f"libhlt_{args.kernel_name}.so"
    if not os.path.exists(simlib):
      print_error(
          f"Could not find {simlib}, expected to be built by the --build_sim step"
      )

    # Run the simulation.
    # The testbench side of things (which is in LLVM-MLIR format) is passed to
    # the mlir-cpu-runner and interpreted. The mlir-cpu-runner will look for the
    # provided entry point and start execution from there.
    # Within our lowered LLVM code, we have references to the (async) function
    # identifiers '{kernel_name}_call' and '{kernel_name}_await' (what is generated
    # by the HLT wrapper). Definitions for these functions are provided through
    # the simulator shared library (simlib).
    tb_cmd = " ".join([
        "mlir-cpu-runner", f"-e {args.tb_entry} -entry-point-result=i32 -O3",
        f"-shared-libs={libdir}/libmlir_c_runner_utils.so",
        f"-shared-libs={libdir}/libmlir_runner_utils.so",
        f"-shared-libs={simlib} {self.tb_llvm}"
    ])
    print_info(
        "WARNING: It has been observed that running the simulator through "
        "the hlstool script occasionally deadlocks the process. This is an unresolved "
        "issue. If you are experiencing this issue, please try running the simulation "
        "command directly on the command line.")
    print_info("Running simulation with command: " + tb_cmd)
    run_tool([tb_cmd], self.tb_output, shell=True)

    print_info("Testbench ran successfully. Output is in {}".format(
        self.tb_output))
    if not args.no_trace and os.path.exists(args.vcd):
      print_info("VCD file is in {}".format(args.vcd))


class StaticMode(HLSMode):
  # TODO: implement static mode

  def __init__(self):
    super().__init__('static')

  def add_arguments(self, subparser):
    pass


class MixedMode(HLSMode):
  # TODO: implement mixed dynamic/static mode

  def __init__(self):
    super().__init__('mixed')

  def add_arguments(self, subparser):
    pass


# Handles for the global 'Mode' objects
dynMode = DynamicMode()
staticMode = StaticMode()


def parse_args(parser):
  global mode
  global args
  args = parser.parse_args()
  print_header("Parsing and validating arguments")

  # First we validate the general arguments.
  if not args.tb_file and not args.kernel_file and not args.kernel_name:
    parser.error(
        "Must specify either testbench name (to infer kernel and kernel name)"
        " or kernel file and kernel name.")
  if args.tb_file and not args.kernel_file and not args.kernel_name:
    # Infer kernel file and name from testbench
    print_info("Inferring kernel file and name from testbench name.")
    dirname = os.path.dirname(args.tb_file)
    basename = os.path.basename(args.tb_file)
    basename = os.path.splitext(basename)[0]

    if not basename.startswith("tst_"):
      parser.error("Testbench name must start with 'tst_' in inference mode")
      sys.exit(1)

    basename = basename[4:]
    args.kernel_file = os.path.join(dirname, basename + ".c")
    args.kernel_name = basename
  elif not args.kernel_file or not args.kernel_name:
    parser.error("Must specify kernel file and kernel name")
  else:
    parser.error(
        "Couldn't determine the requested kernel to synthesize, exiting...")

  print_info("using kernel file: {}".format(args.kernel_file))
  print_info("using kernel name: {}".format(args.kernel_name))
  print_info("using testbench file: {}".format(args.tb_file))

  # Set current mode
  if args.mode == 'dynamic':
    mode = dynMode
  elif args.mode == 'static':
    mode = staticMode
  else:
    parser.print_help()
    sys.exit(1)

  # Parse mode arguments
  print_step(f"Parsing '{mode.name}' mode arguments")
  mode.parse_arguments(args)
  print_info("Arguments parsed and validated successfully!")


# An entry point
if __name__ == '__main__':
  # and argparser taking a mandatory argument "mode"
  parser = argparse.ArgumentParser(
      description="""
HLSTool is a tool for driving an end-to-end MLIR based HLS flow.


Usage:
Arguments are provided at two levels. First, generic arguments are specified, which
applies to any mode. The second level are mode specific arguments.
Generic arguments are specified before the (positional) mode argument.
To see the arguments for a specific mode, use\n
   'hlstool {mode} --help'
""",
      formatter_class=argparse.RawTextHelpFormatter)

  # A sub parser for the "dynamic" mode
  subparsers = parser.add_subparsers(help='Mode options', dest='mode')

  # General arguments
  parser.add_argument('--silent',
                      action='store_true',
                      help='Silent mode; suppress all output.',
                      default=False)

  parser.add_argument('--kernel_file',
                      type=str,
                      help='Path to the file containing the kernel.',
                      required=False)

  parser.add_argument(
      '--tb_file',
      type=str,
      help='Testbench file. If only this is specified, the kernel '
      'name and kernel file are inferred from the testbench name. '
      'When inferring this, testbenches are expected to be named \'tst_${kernel_name}.c\'.',
      required=False)

  parser.add_argument(
      '--tb_entry',
      type=str,
      help=
      'Testbench entry point. If not specified, the default entry point is used.',
      required=False,
      default='main')

  parser.add_argument(
      '--kernel_name',
      type=str,
      help='The kernel name is the name of the function within the '
      'kernel file which is to be compiled.',
      required=False)

  parser.add_argument('--outdir',
                      type=str,
                      help='Output directory. If not specified, '
                      'the output directory is the current working directory.',
                      required=False,
                      default=os.getcwd())

  parser.add_argument("--vcd",
                      type=str,
                      help="Path to a VCD file generated by the testbench.",
                      required=False)

  parser.add_argument("--no_trace",
                      action='store_true',
                      help="Disable tracing during simulation.",
                      required=False)
  parser.add_argument(
      "--vlt_threads",
      type=int,
      help="Number of Verilator threads to use. Defaults to the "
      "number of available threads / 2.",
      required=False,
      default=multiprocessing.cpu_count() // 2)

  parser.add_argument(
      "--rebuild",
      action='store_true',
      help="Always rebuild any output file of the tool. If this is not set, "
      "steps will be skipped when an expected output file already exists.",
      default=False)

  parser.add_argument(
      "--synth",
      action='store_true',
      help="Run Vivado and generate a resource estimate. An output text file "
      "will be generated in the output directory.")

  # Add mode arguments
  dynMode.add_arguments(subparsers)
  staticMode.add_arguments(subparsers)

  # Parse arguments
  parse_args(parser)

  # Move to the output directory
  os.chdir(args.outdir)
  print_info("Working directory is now {}".format(args.outdir))

  # Run the current mode
  print_header(f"Running '{mode.name}' mode")
  mode.run()
