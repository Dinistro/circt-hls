#!/usr/bin/env python3
import sys

# Use the report parser already present in Calyx
sys.path.append("../calyx/fud/fud/stages/vivado/")
from rpt import RPTParser

import subprocess
from vcdvcd import VCDVCD
from dataclasses import dataclass
import os
import json
import argparse


class VCDEvaluator:

  def __init__(self, fn):
    self.vcd = VCDVCD(fn)

  def exectime(self, cp):
    """
    Returns the estimated execution time of this VCD file given a clock period.
    """
    cycles = self.getCycles()
    return cycles * cp

  def get_cycles(self):
    """
    Estimates the number of cycles in the vcd file.
    """
    step = 0
    # Run until reset is deasserted
    # ...

    # step through the clock trace, incrementing the cycle count on each rising
    # edge of the clock.
    clockTrace = None
    for clkName in ["clock", "clk"]:
      if clkName in self.vcd.signals:
        clockTrace = self.vcd.signals[clkName]
        break
    if clockTrace is None:
      raise Exception("Could not find clock signal")
    state = False

    cycles = 0
    while step < self.vcd.endtime:
      traceTrace = clockTrace[step] == 1
      if traceTrace != state:
        if state:
          cycles += 1
        state = traceTrace

    return cycles


def run_hls_tool(args):
  cmd = " ".join(args)
  proc = subprocess.Popen(cmd,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          shell=True)
  code = proc.wait()
  stdOut, stdErr = proc.communicate()
  stdOut = stdOut.decode("utf-8")
  stdErr = stdErr.decode("utf-8")
  if code != 0:
    print("Error running HLS tool:")
    print(stdOut)
    print(stdErr)
    print("Return code:", code)
    exit(code)


@dataclass
class Experiment:
  # Name of this experiment
  name: str
  # Testbench file of the experiment. The kernel name is inferred from this.
  tb: str
  # Number of times the kernel is called (in a loop) in its testbench
  kernel_calls: int

  def run(self):
    """
    Runs the experiment and prints the results.
    """
    print("Running experiment: ", self.name)
    hlstool_args = ["hlstool"]
    hlstool_args.append("--synth")  # Synthesize the design
    hlstool_args.append("--tb_file " + self.tb)
    hlstool_args.append("dynamic")  # Dynamically scheduled HLS
    hlstool_args.append("--run_sim")  # Run the testbench
    run_hls_tool(hlstool_args)


# =============================================================================
# Experiments
# =============================================================================

if __name__ == "__main__":
  # argparser which takes an "experiments" json file argument
  # and runs the experiments in that file.
  #
  parser = argparse.ArgumentParser(
      description="Run a set of experiments on a given testbench.")
  parser.add_argument("experiments",
                      help="JSON file containing the experiments to run.",
                      type=str)

  args = parser.parse_args()

  if not os.path.isfile(args.experiments):
    print("Experiments file does not exist: ", args.experiments)
    exit(1)

  experiments = []
  with open(args.experiments) as f:
    expFile = json.load(f)
    for expName, expValues in expFile.items():
      experiments.append(
          Experiment(expName, expValues["tb"], expValues["kernel_calls"]))

  print("Loaded experiments:")
  for experiment in experiments:
    print("  ", experiment.name)

  # create "results" directory if not exists
  if not os.path.exists("results"):
    os.makedirs("results")

  # Run the experiments
  for experiment in experiments:
    experiment.run()
